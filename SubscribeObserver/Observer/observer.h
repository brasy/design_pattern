#pragma once
/* 观察者模式（Observer Pattern）
 *   定义了对象间的一对多的依赖关系，让多个观察者对象同时监听某一个主题对象（被观察者）。
 *   当主题对象发生更改时，通知所有观察者，让它们能够自动更新。
 * Subject（抽象主题）：跟踪所有观察者，提供添加和删除观察者的接口。
 * Observer（抽象观察者）：为具体观察者定义一个更新接口，在主题的改变通知时，进行自我更新。
 * ConcreteSubject（具体主题）：将有关状态存入各ConcreteObserver 对象。当具体主题的状态发生任何更改时，通知所有观察者。
 * ConcreteObserver（具体观察者）：维护一个指向ConcreteSubject对象的引用;
 *                              实现Observer的更新接口，使本身的状态与主题的状态相一致。
 * 适用场景：
 *   有多个子类共有的方法，且逻辑相同。
 *   重要的、复杂的方法，可以考虑作为模板方法。
 * 优点：
 *   观察者和被观察者是抽象耦合的
 *   建立一套触发机制
 * 缺点：
 *   如果一个被观察者对象有很多的直接和间接的观察者，将所有的观察者都通知到会花费很多时间。
 *   如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
 *   观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
*/

class Observer
{
public:
    virtual ~Observer() = default;
    virtual void update(float value) = 0;
};

